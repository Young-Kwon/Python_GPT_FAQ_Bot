"""
Edubot

Description: A Discord bot designed for educational assistance, integrating OpenAI's GPT models for dynamic interaction and response generation. It performs sentiment analysis and semantic processing on user inputs to enhance the conversation experience. This bot can classify messages for safety, emotional tone, and type of speech act, and it maintains a history of interactions to provide context for responses.
Functions:
    add_history - Tracks and stores user-bot interaction history.
    get_history - Retrieves the interaction history for a specific user.
    classify_message - Analyzes and classifies the content of messages.
    parse_classification - Parses the classification of messages into individual components.
    generate_response - Generates bot responses to user messages.
    generate_response_internal - Internal helper function for response generation with a timeout.
    on_ready - Indicates when the bot is ready and operational.
    on_message - Handles incoming messages and generates responses.

Author: Young Sang Kwon
Date: Nov 21, 2023
Version: 1.0
"""
import discord
import openai
import asyncio
import httpx

# Discord client initialization
intents = discord.Intents.default()
intents.message_content = True
client = discord.Client(intents=intents)

# Load the API tokens
with open("bot_token_gptbot.txt", "r") as file:
    DISCORD_BOT_KEY = file.read().strip()

with open("gpt_api.txt", "r") as file:
    OPEN_API_KEY = file.read().strip()

# OpenAI client initialization
openai.api_key = OPEN_API_KEY

# User interaction history storage
history = dict()

def add_history(user_id: str, user_text: str, bot_text: str):
    """
    Tracks and stores user-bot interaction history.
    Args- user_id (str): The unique identifier of the user.
          user_text (str): The text message sent by the user.
          bot_text (str): The text response generated by the bot.
    Returns- None
    """    
    if user_id not in history:
        history[user_id] = []
    history[user_id].append({"user": user_text, "bot": bot_text})
    if len(history[user_id]) > 10:
        history[user_id].pop(0)

def get_history(user_id: str) -> list:
    """
    Retrieves the interaction history for a specific user.
    Args- user_id (str): The unique identifier of the user.
    Returns- list: A list of dictionaries containing user and bot messages.
    """    
    return history.get(user_id, [])

def classify_message(message_content):
    """
    Analyzes and classifies a message based on its content.
    Args- message_content (str): The content of the message to classify.
    Returns- tuple: A tuple containing the classifications for safety, emotional tone, and speech act.
    """    
    prompt = f"""
    Analyze the following message and classify it in terms of:
    - Safety (safe, sensitive, unsafe)
    - Emotional tone (positive, neutral, negative)
    - Speech act (question, statement, command)
    
    Message: '{message_content}'
    
    Classification:
    """
    classification_response = openai.completions.create(
        model="text-davinci-003",
        prompt=prompt,
        max_tokens=60
    )
    classification = classification_response.choices[0].text.strip()
    safety, emotional_tone, speech_act = parse_classification(classification)
    return safety, emotional_tone, speech_act

def parse_classification(classification):
    """
    Parses the classification string into individual components.
    Args- classification (str): The classification string returned by OpenAI.
    Returns- tuple: A tuple containing safety, emotional tone, and speech act classifications.
    """    
    lines = classification.split('\n')
    safety = lines[0].split(': ')[1] if len(lines) > 0 else 'Unknown'
    emotional_tone = lines[1].split(': ')[1] if len(lines) > 1 else 'Unknown'
    speech_act = lines[2].split(': ')[1] if len(lines) > 2 else 'Unknown'
    return safety, emotional_tone, speech_act

async def generate_response(message_content, user_id):
    """
    Generates a response to a user message using the OpenAI model.
    Args- message_content (str): The content of the user's message.
          user_id (str): The unique identifier of the user.
    Returns- str: The generated response from the bot.
    """    
    try:
        response = await asyncio.wait_for(generate_response_internal(message_content, user_id), timeout=20)
        return response
    except asyncio.TimeoutError:
        return "I'm sorry, I wasn't able to process your request in time. Please feel free to ask another question."

async def generate_response_internal(message_content, user_id):
    """
    Internal method to generate a response. It includes a timeout for the response generation.
    Args- message_content (str): The content of the user's message.
        user_id (str): The unique identifier of the user.
    Returns- str: The generated response from the bot or an error message if the request times out.
    """    
    history_messages = get_history(user_id)
    messages = [{"role": "user", "content": msg['user']} for msg in history_messages] + \
               [{"role": "system", "content": msg['bot']} for msg in history_messages] + \
               [{"role": "user", "content": message_content}]

    # Timeout
    timeout = 20

    async with httpx.AsyncClient(timeout=timeout) as client:
        response = await client.post(
            'https://api.openai.com/v1/chat/completions',
            json={
                "model": "gpt-3.5-turbo",
                "messages": messages
            },
            headers={
                "Authorization": f"Bearer {OPEN_API_KEY}"
            }
        )

    if response.status_code == 200:
        data = response.json()
        bot_response_text = data['choices'][0]['message']['content']
        return bot_response_text
    else:
        return "Sorry, I couldn't process your request."

@client.event
async def on_ready():
    """
    Event handler for when the Discord bot is ready and operational.
    Outputs a confirmation message to the console.
    """    
    print(f'We have logged in as {client.user}')

@client.event
async def on_message(message):
    """
    Event handler for incoming Discord messages.
    Processes messages, generates responses, and manages user interaction.
    Args- message: The incoming Discord message object.
    """
    if message.author == client.user:
        return

    if message.content.lower() == "hello":
        await message.channel.send("Welcome to Edubot!")

    elif message.content.lower() == "bye":
        await message.channel.send("See you next time!")
        await client.close()    

    user_id = str(message.author.id)
    message_content = message.content
    classification = classify_message(message_content)

    if classification == "unsafe":
        bot_response_text = "Sorry, I can't respond to this message."
    else:
        bot_response_text = await generate_response(message_content, user_id)
    add_history(user_id, message_content, bot_response_text)
    await message.channel.send(f"{bot_response_text}")

client.run(DISCORD_BOT_KEY)
